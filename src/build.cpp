#include "build.h"
#include "log.h"
#include "res.h"
#include "utils/utils.h"
#include "toml/dependency.h"
#include "toml/default/default.h"
#include "plugin/built-in/utils.h"
#include "cmd/cmake.h"

bool VersionInfo::operator>(const VersionInfo &other) const
{
    return (this->x > other.x) ||
           (this->x == other.x && this->y > other.y) ||
           (this->x == other.x && this->y == other.y && this->z > other.z);
}

VersionInfo VersionInfo::parse(const std::string &str)
{
    auto ls = split(str, ".");
    if (ls.size() != 3)
        throw std::runtime_error("Invalid version string: " + str);
    return {std::stoi(ls[0]), std::stoi(ls[1]), std::stoi(ls[2])};
}

std::string CMakeOutContent::push(const CMakeOutBlock &block)
{
    auto iter = std::find_if(content.begin(), content.end(),
                             [&block](const CMakeOutBlock &b)
                             { return b.unique == block.unique; });
    if (iter == content.end())
        content.push_back(block);
    else if (block.version > iter->version)
    {
        *iter = block;
        LOG_INFO("Merge dependencies: \n    ",
                 block.path, "  ", block.version, "\nand\n    ",
                 iter->path, "  ", iter->version, "\n->\n    ",
                 block.path, "  ", block.version);
    }
    else
    {
        LOG_INFO("Merge dependencies: \n    ",
                 block.path, "  ", block.version, "\nand\n    ",
                 iter->path, "  ", iter->version, "\n->\n    ",
                 iter->path, "  ", iter->version);
        return iter->unique;
    }
    return block.unique;
}

void CMakeOutContent::write_to(std::ofstream &ofs)
{
    for (const auto &[_1, content, _2, version, path] : this->content)
        ofs << "# Generated by cup" << path << "  " << version << "\n"
            << content << "\n\n";
}

void CMakeOutContent::write_global_to(std::ofstream &ofs)
{
    for (const auto &[_1, _2, content_global, version, path] : this->content)
        ofs << "# Generated by cup" << path << "  " << version << "\n"
            << content_global << "\n\n";
}

std::ostream &operator<<(std::ostream &os, const VersionInfo &v)
{
    return os << "v" << v.x << "." << v.y << "." << v.z;
}

bool exists_intersetion(const std::vector<std::string> &a, const std::vector<std::string> &b)
{
    for (const auto &i : a)
        if (std::find(b.begin(), b.end(), i) != b.end())
            return true;
    return false;
}

std::string Build::generate_cmake(const fs::path &cup, const std::optional<FromParent> &dep_info)
{
    auto config = data::parse_toml_file<data::Default>(cup / "cup.toml");
    auto has_cycle = std::find_if(cycle_check.begin(), cycle_check.end(),
                                  [&config](const std::string &s)
                                  { return s == config.project.name; }) != cycle_check.end();
    cycle_check.push_back(config.project.name);
    if (has_cycle)
        throw std::runtime_error("Cycle dependency detected: " + join(cycle_check, " -> "));

    if (!dep_info)
    {
        this->name = config.project.name;
        if (config.build && config.build->generator)
            this->generator = *config.build->generator;
        else
        {
            this->generator =
#ifdef _WIN32
                "Visual Studio 17 2022"
#else
                "Unix Makefiles"
#endif
                ;
            LOG_WARN("Generator is not specified. Use default generator: ", this->generator);
        }
        if (config.build && config.build->jobs)
        {
            auto count = std::max((data::Integer)0, *config.build->jobs);
            count = count == 0 ? std::thread::hardware_concurrency() : count;
            count = std::max(count, (data::Integer)1);
            this->jobs = count;
        }
        else
        {
            this->jobs = 1;
        }
        if (config.build && config.build->export_data)
            this->compile_commands = config.build->export_data->compile_commands;
    }
    else
    {
        if (config.build && config.build->generator && this->generator != *config.build->generator)
            LOG_WARN("Generator of dependency ", cup, " is different from root. It maybe cause build failure.");
    }
    auto plugin = PluginLoader(config.project.type);
    std::vector<std::string> this_features;
    if (dep_info)
        this_features = get_features(dep_info->features, config.features);
    else if (config.build && config.build->features)
        this_features = get_features(config.build->features, config.features);

    std::set<std::string> vaild_dependencies;
    std::vector<std::string> expand_features;
    for (const auto &[name, info] : config.dependencies.value_or(std::map<std::string, data::Dependency>{}))
    {
        if (info.optional && !exists_intersetion(this_features, *info.optional))
            continue;
        auto [path, version] = get_path(info, true, cup);
        std::string dep_name;
        {
            auto dep_config = data::parse_toml_file<data::Default>(path / "cup.toml");
            dep_name = dep_config.project.name;
        }
        auto vaild_dep_name = this->generate_cmake(
            path,
            FromParent{
                .key = name,
                .features = info.features.value_or(std::vector<std::string>{}),
                .root_dir = dep_info ? dep_info->root_dir : cup,
            });
        if (vaild_dep_name == dep_name)
            vaild_dependencies.insert(name);
    }

    CMakeContext ctx{
        .name = dep_info ? dep_info->key : config.project.name,
        .cmake_version = this->cmake_version,
        .current_dir = cup,
        .root_dir = dep_info ? dep_info->root_dir : cup,
        .features = this_features,
        .dependencies = vaild_dependencies,
    };
    std::optional<std::string> except;
    auto out_content = plugin->gen_cmake(ctx, dep_info.has_value(), except);
    if (except)
        throw std::runtime_error(*except);
    auto out_g_content = plugin->gen_cmake_global(ctx, dep_info.has_value(), except);
    if (except)
        throw std::runtime_error(*except);
    CMakeOutBlock block{
        .unique = config.project.name,
        .content = out_content,
        .content_global = out_g_content,
        .version = VersionInfo::parse(config.project.version),
        .path = cup,
    };
    this->cycle_check.pop_back();
    return this->output.push(block);
}

Build::Build(const cmd::Args &args) : SubCommand(args)
{
    this->is_release = args.has_flag("release") || args.has_flag("r");
    if (args.has_config("dir") && !args.getConfig().at("dir").empty())
        this->root = args.getConfig().at("dir")[0];
    else
        this->root = ".";
    if (this->root.is_relative())
        this->root = fs::current_path() / this->root;
    this->root = this->root.lexically_normal();
    if (args.getPositions().size() > 1)
        this->command = args.getPositions()[1];
}

int Build::run()
{
    this->generate_cmake(this->root);

    auto build_dir = Resource::build(this->root);
    if (!fs::exists(build_dir))
        fs::create_directories(build_dir);
    {
        std::ofstream ofs(build_dir / "CMakeLists.txt");
        ofs << "cmake_minimum_required(VERSION " << this->cmake_version.first << "." << this->cmake_version.second << ")\n";
        if (this->is_release)
            ofs <<
#include "template/release.cmake"
                << std::endl
                << std::endl;
        else
            ofs <<
#include "template/debug.cmake"
                << std::endl
                << std::endl;
        if (this->compile_commands)
            ofs << "set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n";
        this->output.write_global_to(ofs);
        ofs << "project(" << this->name << ")\n\n";
        this->output.write_to(ofs);
    }

    cmd::CMake cmake;
    cmake.source(Resource::build(this->root));
    cmake.build_dir(Resource::cmake(this->root));
    cmake.generator(this->generator);

    auto ret = system(cmake.as_command().c_str());
    if (ret != 0)
        throw std::runtime_error("Failed to generate build files.");

    if (this->compile_commands)
    {
        auto compile_commands_path = this->compile_commands.value();
        if (!compile_commands_path.empty() && fs::exists(Resource::cmake(this->root) / "compile_commands.json"))
        {
            if (!fs::exists(compile_commands_path))
                fs::create_directories(compile_commands_path);
            fs::copy_file(Resource::cmake(this->root) / "compile_commands.json",
                          compile_commands_path / "compile_commands.json", fs::copy_options::overwrite_existing);
            LOG_INFO("Copy compile_commands.json to ", compile_commands_path.lexically_normal().string());
        }
        if (!fs::exists(Resource::cmake(this->root) / "compile_commands.json"))
            LOG_WARN("This generator may not support generating compile_commands.json files.");
    }

    cmd::CMake cmake_build;
    cmake_build.build(Resource::cmake(this->root));
    cmake_build.config(this->is_release);
    if (this->target)
        cmake_build.target(*this->target);
    cmake_build.jobs(static_cast<int>(this->jobs));

    ret = system(cmake_build.as_command().c_str());
    if (ret != 0)
        throw std::runtime_error("Failed to build project.");

    return 0;
}
